require 'rails/generators'

module IiifPrint
  # Install Generator Class
  # rubocop:disable Metrics/ClassLength
  class InstallGenerator < Rails::Generators::Base
    source_root File.expand_path('../templates', __FILE__)

    def copy_migrations
      rake "iiif_print:install:migrations"
    end

    def register_worktypes
      inject_into_file 'config/initializers/hyrax.rb',
                       after: "Hyrax.config do |config|\n" do
        "  # Configuration generated by `rails g iiif_print:install`\n" \
          "  config.callback.set(:after_create_fileset) do |file_set, user|\n" \
          "    require 'iiif_print'\n" \
          "    IiifPrint::Data.handle_after_create_fileset(file_set, user)\n" \
          "  end\n" \
          "  #== END GENERATED iiif_print CONFIG ==\n\n"
      end
    end

    def inject_routes
      inject_into_file 'config/routes.rb',
                       after: "Rails.application.routes.draw do\n" do
        "\n  mount IiifPrint::Engine => '/'\n"
      end
    end

    def add_solr_doc
      inject_into_file 'app/models/solr_document.rb',
                       after: "include Hyrax::SolrDocumentBehavior" do
        "\n  include IiifPrint::Solr::Document\n  attribute :is_child, Solr::String, 'is_child_bsi'"
      end
    end

    def verify_biiif_installed
      return if IO.read('app/controllers/catalog_controller.rb').include?('include BlacklightIiifSearch::Controller')
      say_status('info',
                 'BLACKLIGHT IIIF SEARCH NOT INSTALLED; INSTALLING BLACKLIGHT IIIF SEARCH',
                 :blue)
      generate 'blacklight_iiif_search:install'
    end

    def iiif_configuration
      generate 'iiif_print:blacklight_iiif_search'
    end

    # NOTE: BlacklightAdvancedSearch generator installs a view partial by default,
    # remove it after install, unless app has already customized that view partial
    def verify_blacklight_adv_search_installed
      return if IO.read('app/controllers/catalog_controller.rb').include?('include BlacklightAdvancedSearch::Controller')
      say_status('info', 'INSTALLING BLACKLIGHT ADVANCED SEARCH', :blue)
      search_form_path = 'app/views/catalog/_search_form.html.erb'
      existing_search_form = File.exist?(search_form_path) ? true : false
      generate 'blacklight_advanced_search:install', '--force'
      remove_file search_form_path unless existing_search_form
    end

    def advanced_search_configuration
      generate 'iiif_print:blacklight_advanced_search'
    end

    def catalog_controller_configuration
      generate 'iiif_print:catalog_controller'
    end

    def inject_configuration
      copy_file 'config/initializers/iiif_print.rb'
    end

    def add_helper
      copy_file "iiif_print_helper.rb", "app/helpers/iiif_print_helper.rb"
    end

    def inject_assets
      generate 'iiif_print:assets'
    end

    def add_manifest_builder_decorator
      # supports display of children in index and search
      copy_file 'manifest_builder_service_decorator.rb', 'app/services/hyrax/manifest_builder_service_decorator.rb'
    end

    def add_faceted_attribute_decorator
      # supports display of children in index and search
      copy_file 'faceted_attribute_renderer_decorator.rb', 'app/renderers/hyrax/renderers/faceted_attribute_renderer_decorator.rb'
    end

    def gather_work_types
      # check if this is a hyku application
      switch!(Account.first) if defined? Account

      @work_types = Hyrax.config.curation_concerns.map(&:to_s)
    end

    def add_child_indexer
      # adds ChildIndexer to work indexers
      @work_types.each do |work_type|
        file = "app/indexers/#{work_type.underscore}_indexer.rb"
        file_text = File.read(file)
        insert = "  include IiifPrint::ChildIndexer\n"
        next if file_text.include?(insert)
        insert_into_file file, before: /\nend/ do
          "\n#{insert}"
        end
      end
    end

    def add_file_set_indexer
      # adds to file_set indexers
      file = "app/indexers/hyrax/file_set_indexer.rb"
      return copy_file "file_set_indexer_decorator.rb", "app/indexers/hyrax/file_set_indexer_decorator.rb" unless File.exist?(file)

      file_text = File.read(file)
      insert = "    include IiifPrint::FileSetIndexer\n"
      if file_text.include?('    include Hyrax::IndexesBasicMetadata')
        insert_into_file file, after: /    include Hyrax::IndexesBasicMetadata/ do
          "\n#{insert}"
        end
      else
        insert_into_file file, before: /\nend/ do
          "\n#{insert}"
        end
      end
    end

    def add_set_child_module
      # adds SetChildFlag to work type indexers
      @work_types.each do |work_type|
        file = "app/models/#{work_type.underscore}.rb"
        file_text = File.read(file)
        insert = "  include IiifPrint::SetChildFlag\n"
        next if file_text.include?(insert)
        insert_into_file file, after: /  include ::Hyrax::WorkBehavior/ do
          "\n#{insert}"
        end
      end
    end

    # rubocop:disable Metrics/MethodLength
    def modify_iiif_manifest_presenter
      gsub_regex = /^(?!\s*$)/ # find the beginning of each line unless the line is blank
      indent = " " * 2
      # using squiggly heredoc syntax to improve readability
      search_service_snippet = <<~SEARCH_SERVICE.gsub(gsub_regex, indent * 3).chomp
        url = Rails.application.routes.url_helpers.solr_document_iiif_search_url(id, host: hostname)
        Site.account.ssl_configured ? url.sub(/\\Ahttp:/, 'https:') : url
      SEARCH_SERVICE
      manifest_url_snippet = <<~MANIFEST_URL.gsub(gsub_regex, indent * 3).chomp
        return '' if id.blank?

        url_helper = Rails.application.routes.url_helpers
        if hyku?
          protocol = Site.account.ssl_configured ? 'https' : 'http'
          url_helper.polymorphic_url([:manifest, model], host: hostname, protocol: protocol)
        else
          url_helper.polymorphic_url([:manifest, model], host: hostname)
        end
      MANIFEST_URL
      additional_methods_snippet = <<~ADDITIONAL_METHODS.gsub(gsub_regex, indent * 2).prepend("\n")
        def hyku?
          Object.const_defined?(:Site)
        end

        def sequence_rendering
          Array(try(:rendering_ids)).map do |file_set_id|
            rendering = file_set_presenters.find { |p| p.id == file_set_id }
            next unless rendering

            { '@id' => Hyrax::Engine.routes.url_helpers.download_url(rendering.id, host: hostname),
              'format' => rendering.mime_type.presence || I18n.t(\"hyrax.manifest.unknown_mime_text\"),
              'label' => I18n.t(\"hyrax.manifest.download_text\") + (rendering.label || '') }
          end.flatten
        end

        module FactoryDecorator
          def build
            ids.map do |id|
              solr_doc = load_docs.find { |doc| doc.id == id }
              next unless solr_doc

              if solr_doc.file_set?
                presenter_class.for(solr_doc)
              elsif Hyrax.config.curation_concerns.include?(solr_doc.hydra_model)
                # look up file set ids and loop through those
                file_set_docs = load_file_set_docs(solr_doc.file_set_ids)
                file_set_docs.map { |doc| presenter_class.for(doc) } if file_set_docs.length
              end
            end.flatten.compact
          end

          private

            # still create the manifest if the parent work has images attached but the child works do not
            def load_file_set_docs(file_set_ids)
              return [] if file_set_ids.nil?

              query(\"{!terms f=id}\#{file_set_ids.join(',')}\", rows: 1000)
                .map { |res| ::SolrDocument.new(res) }
            end
        end
      ADDITIONAL_METHODS
      decorator_snippet = <<~DECORATOR
        Hyrax::IiifManifestPresenter::Factory.prepend(Hyrax::IiifManifestPresenterDecorator::FactoryDecorator)
      DECORATOR
      file = 'app/presenters/hyrax/iiif_manifest_presenter_decorator.rb'
      regexes = [
        /(?<=search_service\n)(.*?)(?=\n    end)/m, # find the lines inside #search_service
        /(?<=manifest_url\n)(.*?)(?=\n    end)/m, # find the lines inside #manifest_url
        /(?<=end\n    end\n)(.*?)(?=  end)/m, # find the line after the last method definition
        /(?<=Hyrax::IiifManifestPresenterDecorator\)\n)(.*?)/ # find the line after decorator prepend
      ]
      code_snippets = [
        search_service_snippet,
        manifest_url_snippet,
        additional_methods_snippet,
        decorator_snippet
      ]

      # prepare a hash for gsub_file command to iterate
      hashes = regexes.zip(code_snippets).map { |regex_and_code_snippet| Hash[file => regex_and_code_snippet] }
      hashes.each do |hash|
        hash.each do |k, v|
          # k is the file and v is an array of the regex and code snippet
          gsub_file k, v.first, v.last
        end
      end
    end
    # rubocop:enable Metrics/MethodLength
  end
  # rubocop:enable Metrics/ClassLength
end
